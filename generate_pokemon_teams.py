import dataclasses
import itertools
from argparse import ArgumentParser

from pandas import read_csv, DataFrame, notna

from pokemon import Pokemon
from pokemon_type import SUPER_EFFECTIVENESS_MAP, ALL_POKEMON_TYPES


@dataclasses.dataclass
class Team:
    pokemon_list: list[Pokemon]
    total_base_stats_sum: int


def main():
    argument_parser = ArgumentParser(
        description="This script accepts an input of candidate Pokémon and outputs a list of potential Pokémon teams sorted by total base stats.")
    argument_parser.add_argument("-i", "--input-file",
                                 dest="input_file_name",
                                 help="Path to the CSV file of candidate Pokémon, as generated by generated_candidate_pokemon_list.py.",
                                 default="candidate_pokemon.csv")
    argument_parser.add_argument("-o", "--output-file", dest="output_file_name", default="teams.csv")
    args = argument_parser.parse_args()

    print("Generating Pokémon teams...")

    starter_pokemon_list, non_starter_pokemon_list = parse_candidate_pokemon_csv(input_file_name=args.input_file_name)

    teams = generate_teams(starter_pokemon_list=starter_pokemon_list, non_starter_pokemon_list=non_starter_pokemon_list)

    DataFrame([{
        "Total Base Stats Sum": team.total_base_stats_sum,
        **{f"Pokémon {i + 1}": team.pokemon_list[i].name for i in range(6)}
    } for team in teams]).to_csv(path_or_buf=args.output_file_name, index=False, encoding="utf-8-sig")

    print(f"Pokémon teams have been successfully generated and output to {args.output_file_name}.")


def has_full_type_coverage(pokemon_list: list[Pokemon]) -> bool:
    super_effective_types = set()
    for pokemon in pokemon_list:
        super_effective_types.update(SUPER_EFFECTIVENESS_MAP[pokemon.type_1])
        if pokemon.type_2:
            super_effective_types.update(SUPER_EFFECTIVENESS_MAP[pokemon.type_2])

    return len(super_effective_types) == len(ALL_POKEMON_TYPES)


def get_stats_total_sum(pokemon_list: list[Pokemon]) -> int:
    return sum([pokemon.total_base_stats for pokemon in pokemon_list])


def generate_teams(starter_pokemon_list: list[Pokemon], non_starter_pokemon_list: list[Pokemon]) -> list[Team]:
    return sorted([
        Team(pokemon_list=team_pokemon_list, total_base_stats_sum=get_stats_total_sum(team_pokemon_list))
        for starter_pokemon in starter_pokemon_list
        for combination in itertools.combinations(non_starter_pokemon_list, 5)
        if has_full_type_coverage(team_pokemon_list := [starter_pokemon, *combination])
    ], key=lambda team: team.total_base_stats_sum, reverse=True)


def parse_candidate_pokemon_csv(input_file_name: str) -> tuple[list[Pokemon], list[Pokemon]]:
    starter_pokemon_list = []
    non_starter_pokemon_list = []

    candidate_pokemon_csv = read_csv(input_file_name)

    for _, pokemon_dict in candidate_pokemon_csv.iterrows():
        pokemon = Pokemon(
            name=pokemon_dict["name"],
            type_1=pokemon_dict["type_1"],
            type_2=pokemon_dict["type_2"] if notna(pokemon_dict["type_2"]) else None,
            total_base_stats=pokemon_dict["total_base_stats"],
            is_starter=pokemon_dict["is_starter"],
            link=pokemon_dict["link"],
        )
        if pokemon.is_starter:
            starter_pokemon_list.append(pokemon)
        else:
            non_starter_pokemon_list.append(pokemon)

    return starter_pokemon_list, non_starter_pokemon_list


if __name__ == "__main__":
    main()
